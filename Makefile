# #############################################################################
# L3: Simple Makefile to build and test Lightweight Logging Library sources
#
# Developed based on SplinterDB (https://github.com/vmware/splinterdb) Makefile
# Modelled on the lines of the Makefile of the LineOfCode project, with which
# L3 will be integrated (See: https://github.com/Soft-Where-Inc/LineOfCode)
#
# This repo contains the core L3 library files: l3.h l3.c, l3.S (assembly)
# It contains test-use-case in C and C++. The core L3 objects have to be
# separately linked with both the C and C++ use-case sample programs.
#
# Therefore, this Makefile is written in a way to compile both the C and C++
# sources with gcc and g++ compilers, respectively. To allow linking the .S
# assembly file with C++ sources, we have to compile l3.c also with C++
# compilers.
#
# Thus, this Makefile provides two separate targets:
#   - Build     : all-c_tests and all-cpp-tests
#   - Run Tests : run-c-tests and run-cpp-tests
#
# to be able to compile
# \copyright Copyright (c) 2024
# #############################################################################

.DEFAULT_GOAL := all

help::
	@echo ' '
	@echo 'Usage:'
	@echo ' '
	@echo 'To build all sample programs and run all unit-tests:'
	@echo ' make clean && CC=g++ CXX=g++ LD=g++ make all'
	@echo ' make run-tests'
	@echo ' '
	@echo 'To build C-sample programs and run unit-tests:'
	@echo ' make clean && CC=gcc LD=g++ make all-c-tests'
	@echo ' make run-c-tests'
	@echo ' '
	@echo 'Alternatively, you may use multiple invocations in this sequence to build all sources:'
	@echo ' '
	@echo 'To build C++-sample .cpp programs and run unit-tests:'
	@echo ' make clean-l3 && CC=g++ CXX=g++ LD=g++ make all-cpp-tests'
	@echo ' make run-cpp-tests'
	@echo ' '
	@echo 'To build C++-sample .cc programs and run unit-tests:'
	@echo ' make clean-l3 && CC=g++ CXX=g++ LD=g++ make all-cc-tests'
	@echo ' make run-cc-tests'
	@echo ' '
	@echo 'Environment variables: '
	@echo ' BUILD_MODE={release,debug}'
	@echo ' BUILD_VERBOSE={0,1}'
	@echo ' L3_LOC_ENABLED=1'
	@echo ' '
	@echo 'To build L3-sample programs with LOC-enabled and run unit-tests:'
	@echo ' make clean    && CC=gcc LD=g++         L3_LOC_ENABLED=1 make all-c-tests && make run-c-tests'
	@echo ' make clean-l3 && CC=g++ CXX=g++ LD=g++ L3_LOC_ENABLED=1 make all-cpp-tests && make run-cpp-tests'
	@echo ' make clean-l3 && CC=g++ CXX=g++ LD=g++ L3_LOC_ENABLED=1 make all-cc-tests && make run-cc-tests'

#
# Verbosity
#
ifndef BUILD_VERBOSE
   BUILD_VERBOSE=0
endif

# Setup echo formatting for messages.
ifeq "$(BUILD_VERBOSE)" "1"
   COMMAND=
   PROLIX=@echo
   BRIEF=@ >/dev/null echo
   # Always print message describe step executed, even in verbose mode.
   # BRIEF_FORMATTED=@ >/dev/null echo
   BRIEF_FORMATTED=@printf
   BRIEF_PARTIAL=@echo -n >/dev/null
else ifeq "$(BUILD_VERBOSE)" "0"
   COMMAND=@
   PROLIX=@ >/dev/null echo
   BRIEF=@echo
   BRIEF_FORMATTED=@printf
   BRIEF_PARTIAL=@echo -n
else
   $(error Unknown BUILD_VERBOSE mode "$(BUILD_VERBOSE)".  Valid values are "0" or "1". Default is "0")
endif

# Compilers to use
CC  ?= gcc
CXX ?= g++
LD  ?= gcc

# ###################################################################
# SOURCE DIRECTORIES AND FILES, Generator Package
# ###################################################################
#
L3PACKAGE   := l3
SRCDIR      := src
INCDIR      := include
L3_SRCDIR   := $(SRCDIR)
L3_INCDIR   := $(INCDIR)
TESTS       := test-use-cases

# Symbols needed to integrate with LineOfCode (LOC) package
LOCPACKAGE      := LineOfCode/loc
LOCGENPY        := $(LOCPACKAGE)/gen_loc_files.py

# Names of files generated by LOC Python generator
LOC_FILENAMES   := loc_filenames.c
LOC_HEADER      := loc.h
LOC_TOKENS      := loc_tokens.h

# ###################################################################
# BUILD DIRECTORIES AND FILES
# ###################################################################
#
ifndef BUILD_ROOT
   BUILD_ROOT := build
endif

#
# Build mode
#
ifndef BUILD_MODE
   BUILD_MODE=release
endif
BUILD_DIR := $(BUILD_MODE)

# E.g., will result in one of: `build/release`, `build/debug`
BUILD_PATH=$(BUILD_ROOT)/$(BUILD_DIR)

# Will result in `build/release/obj`, build/debug/obj`
OBJDIR = $(BUILD_PATH)/obj

# Will result in `build/release/bin`, build/debug/bin`
BINDIR = $(BUILD_PATH)/bin

# ###################################################################
# SOURCE DIRECTORIES AND FILES
# ###################################################################

L3_SRC      := $(L3_SRCDIR)/l3.c
L3_ASSEMBLY := l3.S
L3_SRCS     := $(L3_SRC) $(L3_ASSEMBLY)

# ###################################################################
# Symbols for test-case data files generated by sample programs
# ###################################################################
TMPDIR              := /tmp
TEST_DATA_SUFFIX    := test.dat

L3_C_DATA           := $(TMPDIR)/$(L3PACKAGE).c-$(TEST_DATA_SUFFIX)
L3_C_SMALL_DATA     := $(TMPDIR)/$(L3PACKAGE).c-small-$(TEST_DATA_SUFFIX)
L3_CPP_DATA         := $(TMPDIR)/$(L3PACKAGE).cpp-$(TEST_DATA_SUFFIX)
L3_CPP_SMALL_DATA   := $(TMPDIR)/$(L3PACKAGE).cpp-small-$(TEST_DATA_SUFFIX)
L3_CC_DATA          := $(TMPDIR)/$(L3PACKAGE).cc-$(TEST_DATA_SUFFIX)
L3_CC_SMALL_DATA    := $(TMPDIR)/$(L3PACKAGE).cc-small-$(TEST_DATA_SUFFIX)

# ###################################################################
# ---- Symbols to build test-code sample programs
# ###################################################################

# ##############################################################################
# These symbols and lists generate the  dependencies for each test-use-cases/
# sample program. We have a small collection of C, C++ (.cpp and .cc) sample
# programs as our test "use-cases". In future, more multi-file programs will
# be added to the test-bed, in which case, there will be more than one .o's
# linked to create a test-use-cases example program.
#
# The goal is to build each sample program as its own binary.
#
# To keep the enumeration easy to follow, the rules for building each binary
# are listed separately.
#
# Every example program of the form bin/test-use-cases/<eg-prog> depends on
# obj/test-use-cases/<eg-prog>/*.o -> *.c
# ##############################################################################

# ---- -------------------------------------------------------------------------
# ---- The rules for all stand-alone sample programs follow the same pattern
# ---- as documented here for building the single-file-C-program.
# ---- -------------------------------------------------------------------------
# The top-level dir-name also becomes the name of the resulting binary.
SINGLE_FILE_C_PROGRAM := $(TESTS)/single-file-C-program

# Find all sources in that top-level dir. There may be more than one in future.
SINGLE_FILE_C_PROGRAM_SRCS := $(wildcard $(SINGLE_FILE_C_PROGRAM)/*.c)

# Add L3 package's library file to list of sources to be compiled.
SINGLE_FILE_C_PROGRAM_SRCS += $(L3_SRCS)

# Name of LOC-generated source file.
ifdef L3_LOC_ENABLED
SINGLE_FILE_C_PROGRAM_GENSRC := $(SINGLE_FILE_C_PROGRAM)/$(LOC_FILENAMES)
SINGLE_FILE_C_PROGRAM_SRCS   += $(SINGLE_FILE_C_PROGRAM_GENSRC)
endif

# Map the list of sources to resulting list-of-objects
SINGLE_FILE_C_PROGRAM_OBJS := $(SINGLE_FILE_C_PROGRAM_SRCS:%.c=$(OBJDIR)/%.o)

# Define a dependency of this sample program's binary to its list of objects
SINGLE_FILE_C_PROGRAM_BIN := $(BINDIR)/$(SINGLE_FILE_C_PROGRAM)
$(SINGLE_FILE_C_PROGRAM_BIN): $(SINGLE_FILE_C_PROGRAM_OBJS)

TEST_C_CODE_BINS := $(SINGLE_FILE_C_PROGRAM_BIN)

ifeq "$(BUILD_VERBOSE)" "1"
    $(info )
    $(info ---- Debug ----)
    $(info $$SINGLE_FILE_C_PROGRAM_SRCS = [${SINGLE_FILE_C_PROGRAM_SRCS} ])
    $(info $$SINGLE_FILE_C_PROGRAM_BIN = [${SINGLE_FILE_C_PROGRAM_BIN} ])
    $(info ... <- depends on ...)
    $(info $$SINGLE_FILE_C_PROGRAM_OBJS = [${SINGLE_FILE_C_PROGRAM_OBJS} ])
    $(info $$TEST_C_CODE_BINS = [${TEST_C_CODE_BINS} ])
    $(info )
endif

# ---- -------------------------------------------------------------------------
# ---- Definitions for stand-alone C++ .cpp sample program.
# ---- -------------------------------------------------------------------------
SINGLE_FILE_CPP_PROGRAM := $(TESTS)/single-file-Cpp-program

# Find all sources in that top-level dir. There may be more than one in future.
SINGLE_FILE_CPP_PROGRAM_SRCS := $(wildcard $(SINGLE_FILE_CPP_PROGRAM)/*.cpp)

# Add L3 package's library file to list of sources to be compiled.
SINGLE_FILE_CPP_PROGRAM_SRCS += $(L3_SRCS)

# Name of LOC-generated source file.
ifdef L3_LOC_ENABLED
SINGLE_FILE_CPP_PROGRAM_GENSRC := $(SINGLE_FILE_CPP_PROGRAM)/$(LOC_FILENAMES)
SINGLE_FILE_CPP_PROGRAM_SRCS   += $(SINGLE_FILE_CPP_PROGRAM_GENSRC)
endif

# Map the list of sources to resulting list-of-objects
SINGLE_FILE_CPP_PROGRAM_TMPS := $(SINGLE_FILE_CPP_PROGRAM_SRCS:%.cpp=$(OBJDIR)/%.o)
SINGLE_FILE_CPP_PROGRAM_OBJS := $(SINGLE_FILE_CPP_PROGRAM_TMPS:%.c=$(OBJDIR)/%.o)

# Define a dependency of this sample program's binary to its list of objects
SINGLE_FILE_CPP_PROGRAM_BIN := $(BINDIR)/$(SINGLE_FILE_CPP_PROGRAM)
$(SINGLE_FILE_CPP_PROGRAM_BIN): $(SINGLE_FILE_CPP_PROGRAM_OBJS)

TEST_CPP_CODE_BINS := $(SINGLE_FILE_CPP_PROGRAM_BIN)

ifeq "$(BUILD_VERBOSE)" "1"
    $(info )
    $(info ---- Debug ----)
    $(info $$SINGLE_FILE_CPP_PROGRAM_SRCS = [${SINGLE_FILE_CPP_PROGRAM_SRCS} ])
    $(info $$SINGLE_FILE_CPP_PROGRAM_BIN = [${SINGLE_FILE_CPP_PROGRAM_BIN} ])
    $(info ... <- depends on ...)
    $(info $$SINGLE_FILE_CPP_PROGRAM_OBJS = [${SINGLE_FILE_CPP_PROGRAM_OBJS} ])
    $(info $$TEST_CPP_CODE_BINS = [${TEST_CPP_CODE_BINS} ])
    $(info )
endif

# ---- -------------------------------------------------------------------------
# ---- Definitions for stand-alone C++ .cc sample program.
# ---- -------------------------------------------------------------------------
SINGLE_FILE_CC_PROGRAM := $(TESTS)/single-file-CC-program

# Find all sources in that top-level dir. There may be more than one in future.
SINGLE_FILE_CC_PROGRAM_SRCS := $(wildcard $(SINGLE_FILE_CC_PROGRAM)/*.cc)

# Add L3 package's library file to list of sources to be compiled.
SINGLE_FILE_CC_PROGRAM_SRCS += $(L3_SRCS)

# Name of LOC-generated source file.
ifdef L3_LOC_ENABLED
SINGLE_FILE_CC_PROGRAM_GENSRC := $(SINGLE_FILE_CC_PROGRAM)/$(LOC_FILENAMES)
SINGLE_FILE_CC_PROGRAM_SRCS   += $(SINGLE_FILE_CC_PROGRAM_GENSRC)
endif

# Map the list of sources to resulting list-of-objects
SINGLE_FILE_CC_PROGRAM_TMPS := $(SINGLE_FILE_CC_PROGRAM_SRCS:%.cc=$(OBJDIR)/%.o)
SINGLE_FILE_CC_PROGRAM_OBJS := $(SINGLE_FILE_CC_PROGRAM_TMPS:%.c=$(OBJDIR)/%.o)

# Define a dependency of this sample program's binary to its list of objects
SINGLE_FILE_CC_PROGRAM_BIN := $(BINDIR)/$(SINGLE_FILE_CC_PROGRAM)
$(SINGLE_FILE_CC_PROGRAM_BIN): $(SINGLE_FILE_CC_PROGRAM_OBJS)

TEST_CC_CODE_BINS := $(SINGLE_FILE_CC_PROGRAM_BIN)

# ##############################################################################
# Build symbols for single C & C++ unit-test binary that we run
# ##############################################################################
C_UNIT_TEST_BIN     := $(SINGLE_FILE_C_PROGRAM_BIN)
CPP_UNIT_TEST_BIN   := $(SINGLE_FILE_CPP_PROGRAM_BIN)
CC_UNIT_TEST_BIN    := $(SINGLE_FILE_CC_PROGRAM_BIN)

# ###################################################################
# Report build machine details and compiler version for troubleshooting,
# so we see this output for clean builds, especially in CI-jobs.
# ###################################################################
.PHONY : clean tags
clean:
	uname -a
	$(CC) --version
	rm -rf $(BUILD_ROOT) $(TMPDIR)/$(L3PACKAGE)*$(TEST_DATA_SUFFIX)
	rm -rf $(L3_INCDIR)/loc*.h $(shell find $(TESTS) \( -name loc*.h -or -name loc_file*.c \) -print)

# Delete l3.o object as it needs to be recompiled for inclusion w/C++ sources
clean-l3:
	rm -rf $(OBJDIR)/src/l3.o

# ##############################################################################
# Make build targets begin here. Make definitions below these targets synthesize
# lists of targets and dependencies that will fulfill this target.
# ##############################################################################

all-c-tests:    $(SINGLE_FILE_C_PROGRAM_GENSRC) $(TEST_C_CODE_BINS)

# ------------------------------------------------------------------------------
# Rule: Use Python generator script to generate the LOC-files
# Rule will be triggered for objects defined to be dependent on $(LOC_FILENAMES)
# sources. Use the triggering target's dir-path to generate .h / .c files
# ------------------------------------------------------------------------------
# NOTE: The generation can be done with one of:
#   a) --gen-includes-dir  $(dir $@) - which will generate the loc*.h files in the
#           dir for the sample-program's sources, or
#   b) --gen-includes-dir  $(L3_INCDIR) - which will generate the loc*.h files in
#           common include/ dir.
#
# We do the latter as src/l3.c also needs access to the LOC-definitions, which it
# can't get to if these LOC headers were generated in the sample-program's dir.
#
$(SINGLE_FILE_C_PROGRAM_GENSRC):
	@echo
	@echo "Invoke LOC-generator triggered by: " $@
	@$(LOCGENPY) --gen-includes-dir  $(L3_INCDIR) --gen-source-dir $(dir $@) --src-root-dir $(dir $@) --verbose
	@echo

all-cpp-tests:  $(SINGLE_FILE_CPP_PROGRAM_GENSRC) $(TEST_CPP_CODE_BINS)

$(SINGLE_FILE_CPP_PROGRAM_GENSRC):
	@echo
	@echo "Invoke LOC-generator triggered by: " $@
	@$(LOCGENPY) --gen-includes-dir  $(L3_INCDIR) --gen-source-dir $(dir $@) --src-root-dir $(dir $@) --verbose
	@echo

all-cc-tests:  $(SINGLE_FILE_CC_PROGRAM_GENSRC) $(TEST_CC_CODE_BINS)

$(SINGLE_FILE_CC_PROGRAM_GENSRC):
	@echo
	@echo "Invoke LOC-generator triggered by: " $@
	@$(LOCGENPY) --gen-includes-dir  $(L3_INCDIR) --gen-source-dir $(dir $@) --src-root-dir $(dir $@) --verbose
	@echo

all: all-c-tests all-cpp-tests all-cc-tests

# ##############################################################################
# CFLAGS, LDFLAGS, ETC
# ##############################################################################
#

# -----------------------------------------------------------------------------
# Define the include files' dir-path.
# -----------------------------------------------------------------------------
INCLUDE = -I ./$(L3_INCDIR)
INCLUDE += -I ./$(dir $<)

# use += here, so that extra flags can be provided via the environment
ifeq "$(BUILD_MODE)" "debug"
    CFLAGS += -DDEBUG
endif

# By default, L3-logging runs on its own. To integrate L3 with LOC machinery,
# to squirrel away the loc_t ID value, run: L3_LOC_ENABLED=1 make ...
ifdef L3_LOC_ENABLED
    CFLAGS += -DL3_LOC_ENABLED
    CFLAGS += -DLOC_FILE_INDEX=LOC_$(subst .,_,$(subst -,_,$(notdir $<)))
endif
CFLAGS += -D_GNU_SOURCE -ggdb3 -Wall -Wfatal-errors -Werror


# ##############################################################################
# Automatically create directories, based on
# http://ismail.badawi.io/blog/2017/03/28/automatic-directory-creation-in-make/
# ##############################################################################
#
.SECONDEXPANSION:

.SECONDARY:

%/.:
	$(COMMAND) mkdir -p $@

# These targets prevent circular dependencies arising from the
# recipe for building binaries
$(BINDIR)/.:
	$(COMMAND) mkdir -p $@

$(BINDIR)/%/.:
	$(COMMAND) mkdir -p $@

# ##############################################################################
# RECIPES:
# ##############################################################################
#
# For all-test-code, we need to use -I test-code/<subdir>
# Dependencies for the main executables
COMPILE.c   = $(CC)  $(CFLAGS) $(INCLUDE) -c
COMPILE.cpp = $(CXX) $(CFLAGS) $(INCLUDE) -c
COMPILE.cc  = $(CXX) $(CFLAGS) $(INCLUDE) -c

# Compile each .c file into its .o
# Also define a dependency on the dir in which .o will be produced (@D).
# The secondary expansion will invoke mkdir to create output dirs first.
$(OBJDIR)/%.o: %.c | $$(@D)/.
	$(BRIEF_FORMATTED) "%-20s %-50s [%s]\n" Compiling $< $@
	$(COMMAND) $(COMPILE.c) $< -o $@
	$(PROLIX) # blank line

# Compile each .cpp file into its .o
$(OBJDIR)/%.o: %.cpp | $$(@D)/.
	$(BRIEF_FORMATTED) "%-20s %-50s [%s]\n" Compiling $< $@
	$(COMMAND) $(COMPILE.cpp) $< -o $@
	$(PROLIX) # blank line

# Compile each .cc file into its .o
$(OBJDIR)/%.o: %.cc | $$(@D)/.
	$(BRIEF_FORMATTED) "%-20s %-50s [%s]\n" Compiling $< $@
	$(COMMAND) $(COMPILE.cpp) $< -o $@
	$(PROLIX) # blank line

# Link .o's to produce running binary
# Define dependency on output dir existing, so secondary expansion will
# trigger mkdir to create bin/s output dir.
# If you add "$^" to 'Linking' message, you will see list of .o's being linked
$(BINDIR)/%: | $$(@D)/.
	$(BRIEF_FORMATTED) "%-20s %s\n" Linking $@
	$(COMMAND) $(LD) $(LDFLAGS) $^ -o $@ $(LIBS)
	$(PROLIX) # blank line

#*************************************************************#
# Testing: Make test targets
#*************************************************************#
#

.PHONY: install

run-tests: run-c-tests run-cpp-tests run-cc-tests

run-c-tests: all-c-tests
	pylint l3_dump.py
	@echo
	@echo '---- Run C unit-tests: ----'
	./$(C_UNIT_TEST_BIN)
	@echo
	./l3_dump.py
	@echo
	python3 l3_dump.py $(L3_C_DATA) ./$(C_UNIT_TEST_BIN)
	@echo
	python3 l3_dump.py $(L3_C_SMALL_DATA) ./$(C_UNIT_TEST_BIN)

run-cpp-tests: all-cpp-tests
	@echo
	@echo '---- Run C++ .cpp unit-tests: ----'
	./$(CPP_UNIT_TEST_BIN)
	@echo
	./l3_dump.py
	@echo
	python3 l3_dump.py $(L3_CPP_DATA) ./$(CPP_UNIT_TEST_BIN)
	@echo
	python3 l3_dump.py $(L3_CPP_SMALL_DATA) ./$(CPP_UNIT_TEST_BIN)

run-cc-tests: all-cc-tests
	@echo
	@echo '---- Run Cpp *.cc unit-tests: ----'
	./$(CC_UNIT_TEST_BIN)
	@echo
	./l3_dump.py
	@echo
	python3 l3_dump.py $(L3_CC_DATA) ./$(CC_UNIT_TEST_BIN)
	@echo
	python3 l3_dump.py $(L3_CC_SMALL_DATA) ./$(CC_UNIT_TEST_BIN)

# ###################################################################
#
test-old: test-use-cases/single-file-C-program/test-main.c src/l3.c l3.S include/l3.h
	pylint l3_dump.py
	g++ -I./include -Wall -o test -g -O3 -D_GNU_SOURCE test-use-cases/single-file-C-program/test-main.c src/l3.c l3.S
	./test
	@echo
	./l3_dump.py
	@echo
	python3 l3_dump.py /tmp/l3_test ./test
	@echo
	python3 l3_dump.py /tmp/l3_small_test ./test
