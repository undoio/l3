# #############################################################################
# l3_dump_test.py
#
"""
Collection of basic test cases to exercise different combinations of `make`
commands. Cross-check that the output from the L3 Python dump script
comes out as expected. Verify, either using hard-coded expected outputs,
or outputs generated by using `grep` on source-files, that the outputs
returned by l3_dump.py script are as per the expected outputs.
"""
import os
import sys
import platform
import subprocess as sp
import shlex
from fnmatch import fnmatchcase
# DEBUG: from pprint import pprint

# #############################################################################
# To see output from test-cases run:
# $ pytest --capture=tee-sys l3_dump_test.py -k test_unit_test_basic_dump
# #############################################################################

OS_UNAME_S = platform.system()
if OS_UNAME_S == 'Linux':
    EXP_PLATFORM = 1

elif OS_UNAME_S == 'Darwin':
    EXP_PLATFORM = 2
else:
    # To avoid pylint errors on Mac/OSX.
    EXP_PLATFORM = -1

# #############################################################################
# Setup some variables pointing to diff dir/sub-dir full-paths.
# Dir-tree:
#  /tests/pytests/
#   - <this-file>
# Full dir-path where this tests/  dir lives
L3PytestsDir    = os.path.realpath(os.path.dirname(__file__))
L3RootDir       = os.path.realpath(L3PytestsDir + '/../..')
L3USE_CASES_DIR = L3RootDir + '/use-cases/'

sys.path.append(L3RootDir)

# pylint: disable-msg=import-error,wrong-import-position
import l3_dump

L3DUMPSCRIPT    = 'l3_dump.py'
L3Dump          = L3RootDir + '/' + L3DUMPSCRIPT
L3_DUMP_ARG_LOG_FILE = '--log-file'
L3_DUMP_ARG_BINARY   = '--binary'

L3_LOC_UNSET            = "0"
L3_LOC_DEFAULT          = "1"
L3_LOC_ELF_ENCODING     = "2"

# Ternary: variable = something if condition else something_else
# BUILD_MODE = os.getenv(BUILD_MODE) if BUILD_MODE in os.environ else 'release'
EV_BUILD_MODE = "BUILD_MODE"
if EV_BUILD_MODE in os.environ:
    BUILD_MODE = os.getenv(EV_BUILD_MODE)
else:
    BUILD_MODE = 'release'

# #############################################################################
def test_basic_dir_struct():
    """Basic verification of expected dir structure."""
    assert L3PytestsDir.endswith('pytests')
    assert L3RootDir.endswith('l3')
    assert verify_file_exists(L3RootDir, L3DUMPSCRIPT) is True

# #############################################################################
def test_unit_test_basic_dump():
    """
    Build the unit-tests and invoke the L3-dump utility. Do basic verification
    that the make interfaces to build and run unit-tests work cleanly.
    """
    make_rv = exec_make(['make', 'clean'])
    make_rv = exec_make(['make', 'run-unit-tests'],
                        { "BUILD_VERBOSE": "1", "CC": "g++", "CXX": "g++", "LD": "g++" })
    assert make_rv is True

# #############################################################################
# pylint: disable-next=too-many-locals
def test_unit_test_dump_log_entries():
    """
    Build and run the unit-test, which will create the slow and fast-logging
    dump files. Invoke the L3-dump utility and verify the results are as
    expected.

    **** Maintenance Warning **** There is some hard-coding of targets built
    by make and the data that is generated by the unit-tests. This hard-coding
    here verifies that the workflow is behaving correctly.
    """

    # Just build the unit-tests here via make
    make_rv = exec_make(['make', 'clean'])
    make_rv = exec_make(['make', 'all-unit-tests'],
                        { "BUILD_VERBOSE": "1", "CC": "g++", "CXX": "g++", "LD": "g++" })
    assert make_rv is True

    # Execute the unit-test binary built above.
    binary = L3RootDir + '/build/' + BUILD_MODE + '/bin/unit/l3_dump.py-test'
    exec_rv = exec_binary(binary)
    assert exec_rv is True

    # Verify that LOC-encoding was not-active when log-entries were created
    l3_dump_dat = '/tmp/l3.c-small-unit-test.dat'
    with open(l3_dump_dat, 'rb') as file:
        (_, loc_platform, decode_loc_id) = l3_dump.l3_unpack_loghdr(file)

        assert loc_platform == EXP_PLATFORM
        assert decode_loc_id == int(L3_LOC_UNSET)

    # Invoke the L3-dump script to unpack the slow-log-entries.
    (nentries, tid_list, loc_list, msg_list, arg1_list, arg2_list) \
        = l3_dump.do_main([L3_DUMP_ARG_LOG_FILE, '/tmp/l3.c-small-unit-test.dat',
                           L3_DUMP_ARG_BINARY,    binary],
                          return_logentry_lists = True)

    # -----------------------------------------------------------------------
    # Here is where it gets interesting. Hard-coded verification of expected
    # message and arguments, as unpacked by utility. This is one example of
    # verification using hard-coded expected-outputs lists.
    # -----------------------------------------------------------------------
    exp_msg_list = [  'Simple-log-msg-Args(arg1=1, arg2=2)'
                    , 'Simple-log-msg-Args(arg3=3, arg4=4)'
                    , 'Potential memory overwrite (addr=0xdeadbabe, size=1024)'
                    , 'Invalid buffer handle (addr=0xbeefabcd), lockrec=0x0'
                   ]
    print(msg_list)
    assert msg_list == exp_msg_list

    exp_arg1_list = [ 1, 3, int('0xdeadbabe', 16), int('0xbeefabcd', 16) ]
    assert arg1_list == exp_arg1_list

    exp_arg2_list = [ 2, 4, 1024, 0 ]
    assert arg2_list == exp_arg2_list

    verify_rv = verify_output_lists(nentries, len(exp_msg_list),
                                    tid_list, loc_list,
                                    msg_list,
                                    arg1_list, arg2_list)
    assert verify_rv is True

    # Unit-tests are currently not enabled to run with LOC_ENABLED env-var
    assert verify_loc_field_is_empty(loc_list) is True

    # Invoke the L3-dump script to unpack the fast-log-entries.
    (nentries, tid_list, loc_list, msg_list, arg1_list, arg2_list) \
        = l3_dump.do_main([L3_DUMP_ARG_LOG_FILE, '/tmp/l3.c-fast-unit-test.dat',
                           L3_DUMP_ARG_BINARY,   binary],
                          return_logentry_lists = True)

    exp_msg_list = [  'Fast-log-msg: Args(arg1=1, arg2=2)'
                    , 'Fast-log-msg: Args(arg3=3, arg4=4)'
                    , 'Fast-log-msg: Args(arg1=10, arg2=20)'
                    , 'Fast-log-msg: Potential memory overwrite (addr=0xdeadbabe, size=1024)'
                    , 'Fast-log-msg: Invalid buffer handle (addr=0xbeefabcd), unused=0'
                   ]
    print(msg_list)
    assert exp_msg_list == msg_list

    exp_arg1_list = [ 1, 3, 10, int('0xdeadbabe', 16), int('0xbeefabcd', 16) ]
    assert arg1_list == exp_arg1_list

    exp_arg2_list = [ 2, 4, 20, 1024, 0 ]
    assert arg2_list == exp_arg2_list

    verify_rv = verify_output_lists(nentries, len(exp_msg_list),
                                    tid_list, loc_list,
                                    msg_list,
                                    arg1_list, arg2_list)
    assert verify_rv is True

    # Unit-tests are currently not enabled to run with LOC_ENABLED env-var
    assert verify_loc_field_is_empty(loc_list) is True

# #############################################################################
def test_c_test_dump_log_entries():
    """
    Build and run the C-sample-programs to generate small # of log-entries.
    Invoke the L3-dump utility. Do basic verification that L3 correctly
    unpacks the data logged by L3-logging apis.
    """
    make_rv = exec_make(['make', 'clean'])
    make_rv = exec_make(['make', 'all-c-tests'],
                        { "BUILD_VERBOSE": "1", "CC": "g++", "CXX": "g++", "LD": "g++" })
    assert make_rv is True

    # Execute the C-sample program test binary built above.
    usecase_prog_dir = 'single-file-C-program'
    binary = L3RootDir + '/build/' + BUILD_MODE + '/bin/use-cases/' \
           + usecase_prog_dir

    print(f"Exec {binary=} --unit-tests ...")
    exec_rv = exec_binary([binary, '--unit-tests'])
    assert exec_rv is True

    unpack_rv = verify_l3_dump_unpack('/tmp/l3.c-small-test.dat',
                                      L3_LOC_UNSET, binary,
                                      usecase_prog_dir, 'test-main.c')
    assert unpack_rv is True

# #############################################################################
def test_cpp_test_dump_log_entries():
    """
    Build and run the Cpp-sample-programs to generate small # of log-entries,
    Invoke the L3-dump utility. Do basic verification that L3 correctly
    unpacks the data logged by L3-logging apis.
    """
    make_rv = exec_make(['make', 'clean'])
    make_rv = exec_make(['make', 'all-cpp-tests'],
                        { "BUILD_VERBOSE": "1",
                          "CC": "g++", "CXX": "g++", "LD": "g++",
                        } )
    assert make_rv is True

    # Execute the Cpp-sample program test binary built above.
    usecase_prog_dir = 'single-file-Cpp-program'
    binary = L3RootDir + '/build/' + BUILD_MODE + '/bin/use-cases/' \
           + usecase_prog_dir

    print(f"Exec {binary=} --unit-tests ...")
    exec_rv = exec_binary([binary, '--unit-tests'])
    assert exec_rv is True

    unpack_rv = verify_l3_dump_unpack('/tmp/l3.cpp-small-test.dat',
                                      L3_LOC_UNSET, binary,
                                      usecase_prog_dir, 'test-main.cpp')
    assert unpack_rv is True

# #############################################################################
def test_cc_test_dump_log_entries():
    """
    Build and run the CC-sample-programs to generate small # of log-entries,
    Invoke the L3-dump utility. Do basic verification that L3 correctly
    unpacks the data logged by L3-logging apis.
    """
    make_rv = exec_make(['make', 'clean'])
    make_rv = exec_make(['make', 'all-cc-tests'],
                        { "BUILD_VERBOSE": "1",
                          "CC": "g++", "CXX": "g++", "LD": "g++",
                        } )
    assert make_rv is True

    # Execute the CC-sample program test binary built above.
    usecase_prog_dir = 'single-file-CC-program'
    binary = L3RootDir + '/build/' + BUILD_MODE + '/bin/use-cases/' \
           + usecase_prog_dir

    print(f"Exec {binary=} --unit-tests ...")
    exec_rv = exec_binary([binary, '--unit-tests'])
    assert exec_rv is True

    unpack_rv = verify_l3_dump_unpack('/tmp/l3.cc-small-test.dat',
                                      L3_LOC_UNSET, binary,
                                      usecase_prog_dir, 'test-main.cc')
    assert unpack_rv is True

# #############################################################################
def test_c_test_dump_log_entries_loc_eq_1():
    """
    Build and run the C-sample-programs to generate small # of log-entries,
    with L3_LOC_ENABLED=1. Invoke the L3-dump utility. Do basic verification
    that L3 correctly unpacks the data logged by L3-logging apis.
    """
    make_rv = exec_make(['make', 'clean'])

    make_rv = exec_make(['make', 'all-c-tests'],
                        { "BUILD_VERBOSE": "1",
                          "CC": "gcc", "CXX": "g++", "LD": "g++",
                          "L3_LOC_ENABLED": L3_LOC_DEFAULT} )
    assert make_rv is True

    # Execute the C-sample program test binary built above.
    usecase_prog_dir = 'single-file-C-program'
    binary = L3RootDir + '/build/' + BUILD_MODE + '/bin/use-cases/' \
           + usecase_prog_dir

    print(f"Exec {binary=} --unit-tests ...")
    exec_rv = exec_binary([binary, '--unit-tests'])
    assert exec_rv is True

    unpack_rv = verify_l3_dump_unpack('/tmp/l3.c-small-test.dat',
                                      L3_LOC_DEFAULT, binary,
                                      usecase_prog_dir, 'test-main.c')
    assert unpack_rv is True

# #############################################################################
def test_cpp_test_dump_log_entries_loc_eq_1():
    """
    Build and run the Cpp-sample-programs to generate small # of log-entries,
    with L3_LOC_ENABLED=1. Invoke the L3-dump utility. Do basic verification
    that L3 correctly unpacks the data logged by L3-logging apis.
    """
    make_rv = exec_make(['make', 'clean'])

    make_rv = exec_make(['make', 'all-cpp-tests'],
                        { "BUILD_VERBOSE": "1",
                          "CC": "g++", "CXX": "g++", "LD": "g++",
                          "L3_LOC_ENABLED": L3_LOC_DEFAULT} )
    assert make_rv is True

    # Execute the Cpp-sample program test binary built above.
    usecase_prog_dir = 'single-file-Cpp-program'
    binary = L3RootDir + '/build/' + BUILD_MODE + '/bin/use-cases/' \
           + usecase_prog_dir

    print(f"Exec {binary=} --unit-tests ...")
    exec_rv = exec_binary([binary, '--unit-tests'])
    assert exec_rv is True

    unpack_rv = verify_l3_dump_unpack('/tmp/l3.cpp-small-test.dat',
                                      L3_LOC_DEFAULT, binary,
                                      usecase_prog_dir, 'test-main.cpp')
    assert unpack_rv is True

# #############################################################################
def test_cc_test_dump_log_entries_loc_eq_1():
    """
    Build and run the CC-sample-programs to generate small # of log-entries,
    with L3_LOC_ENABLED=1. Invoke the L3-dump utility. Do basic verification
    that L3 correctly unpacks the data logged by L3-logging apis.
    """
    make_rv = exec_make(['make', 'clean'])

    make_rv = exec_make(['make', 'all-cc-tests'],
                        { "BUILD_VERBOSE": "1",
                          "CC": "g++", "CXX": "g++", "LD": "g++",
                          "L3_LOC_ENABLED": L3_LOC_DEFAULT} )
    assert make_rv is True

    # Execute the CC-sample program test binary built above.
    usecase_prog_dir = 'single-file-CC-program'
    binary = L3RootDir + '/build/' + BUILD_MODE + '/bin/use-cases/' \
           + usecase_prog_dir

    print(f"Exec {binary=} --unit-tests ...")
    exec_rv = exec_binary([binary, '--unit-tests'])
    assert exec_rv is True

    unpack_rv = verify_l3_dump_unpack('/tmp/l3.cc-small-test.dat',
                                      L3_LOC_DEFAULT, binary,
                                      usecase_prog_dir, 'test-main.cc')
    assert unpack_rv is True

# #############################################################################
# pylint: disable-next=too-many-arguments
def verify_output_lists(nentries:int,
                        exp_nentries:int,
                        tid_list:list,
                        loc_list:list,
                        msg_list:list,
                        arg1_list:list,
                        arg2_list:list) -> bool:
    """
    Verify output lists returned by unpacking logic in Py script. We do a
    high-level verification of sizes and some known quantities. Other
    deep-checks are performed in caller's context.
    """
    # -----------------------------------------------------------------------
    # Verify expected # of log-entries. Each log-entry should be cracked-open
    # and each field is returned in a list. Verify output list sizes.
    assert nentries == exp_nentries
    assert len(tid_list) == nentries
    assert len(loc_list) == nentries
    assert len(msg_list) == nentries
    assert len(arg1_list) == nentries
    assert len(arg2_list) == nentries

    # -----------------------------------------------------------------------
    # As in the unit-test a single thread does slow-logging all log-entries
    # must have the same decoded TID value. And, make sure that L3-logging
    # code has generated a valid thread-ID, which should be non-zero.
    assert tid_list[0] != 0
    for tid in tid_list:
        assert tid == tid_list[0]

    print('\n**** Verification of decoded output-lists succeeded.\n')
    return True

# #############################################################################
def verify_msg_lists(msg_list:list[str], exp_msg_list:list[str]) -> bool:
    """
    Verify that the list of printed messages is consistent with the expected
    messages list. The exp_msg_list is generated from the source-code so is
    likely to have print-format specifiers. l3_dump.py's C-print() method
    will replace format-specifiers with actual argument values. So, the best
    we can do is to verify that the prefix at least matches.
    """
    assert len(msg_list) == len(exp_msg_list)

    mctr = 0
    while mctr < len(exp_msg_list):
        print(msg_list[mctr])
        print(exp_msg_list[mctr])

        # Take the prefix of the expected message just prior to 1st occurence
        # of print-format specifier '%'. We need to dip into the dump module's
        # replace() method as it deals with issues around %p -> 0x%x conversion.
        exp_fmtstr = l3_dump.fmtstr_replace(exp_msg_list[mctr])
        exp_fmtstr = exp_fmtstr.split('%')[0]
        assert msg_list[mctr].startswith(exp_fmtstr)
        mctr += 1
    return True


# #############################################################################
def verify_loc_field_is_empty(loc_list:list) -> bool:
    """
    All unit-tests are currently not enabled to generate LOC-ID field.
    We also run sample use-case programs w/ and w/o LOC-enabled.
    This method verifies that the LOC-field in the data unpacked from the log
    file is empty, which should be the case when LOC_ENABLED is OFF.
    """
    # When LOC is not enabled while logging, the unpacking should return a
    # blank string for all LOC-fields.
    assert '' == loc_list[0]
    for loc in loc_list:
        assert loc == loc_list[0]

    return True

# #############################################################################
# pylint: disable-next=too-many-locals
def verify_l3_dump_unpack(l3_dump_dat:str,
                          exp_loc_encoding:str,
                          usecase_binary:str,
                          usecase_prog_dir:str,
                          src_filename:str) -> bool:
    """
    Arguments:
      l3_dump_dat   : L3-generated data file; '/tmp/l3.c-small-test.dat'
      usecase_binary: Program binary built from src_filename;
                      E.g., '../build/release/.
      usecase_prog_dir : Use-case dir-name; 'single-file-C-program'
      src_filename  : Source file-name; 'test-main.c'

    Verification:
     - L3-dump utility returns output lists of unpacked fields
     - Python helper method greps through source-files to build
       expected msg / decoded-loc-text lists
     - Some msg-argument values are hard-coded from program sources.
     - Compare these various lists to confirm that the unpacking of
       the log-entry done by L3-dump script is returning the right data
    """

    # Make sure that caller has not mixed-up args.
    verify_file_exists(L3USE_CASES_DIR + usecase_prog_dir, src_filename)

    # Figure out if LOC-encoding was active when log-entries were created
    with open(l3_dump_dat, 'rb') as file:
        (_, loc_platform, decode_loc_id) = l3_dump.l3_unpack_loghdr(file)

        assert loc_platform == EXP_PLATFORM
        assert decode_loc_id == int(exp_loc_encoding)

    # Invoke the L3-dump script to unpack the slow-log-entries.
    (nentries, tid_list, loc_list, msg_list, arg1_list, arg2_list) \
        = l3_dump.do_main([L3_DUMP_ARG_LOG_FILE, l3_dump_dat,
                           L3_DUMP_ARG_BINARY,    usecase_binary],
                          return_logentry_lists = True)

    # -----------------------------------------------------------------------
    # Here is where it gets interesting. Hard-coded verification of expected
    # message and arguments, as unpacked by utility.
    # grep through source file and generate the expected msgs and
    # unpacked LOC-IDs in a list.
    # -----------------------------------------------------------------------
    (exp_loc_list, exp_msg_list) = build_exp_loc_msg_list(usecase_prog_dir,
                                                          src_filename)
    # DEBUG: pprint(exp_msg_list)
    # DEBUG: pprint(msg_list)
    verify_msg_lists(msg_list, exp_msg_list)

    # LOC-ID will be unpacked only if LOC was generated at logging-time
    if decode_loc_id == int(L3_LOC_DEFAULT):
        assert loc_list == exp_loc_list
    else:
        assert verify_loc_field_is_empty(loc_list) is True

    exp_arg1_list = [ 1,
                      int('0xdeadbabe', 16), int('0xbeefabcd', 16),
                      10, 20
                     ]
    assert arg1_list == exp_arg1_list

    exp_arg2_list = [ 2, 1024, 0, int('0xdeadbeef', 16), int('0xbeefbabe', 16) ]
    assert arg2_list == exp_arg2_list

    verify_rv = verify_output_lists(nentries, len(exp_msg_list),
                                    tid_list, loc_list,
                                    msg_list,
                                    arg1_list, arg2_list)
    assert verify_rv is True
    return verify_rv

# #############################################################################
def verify_file_exists(dirname:str, filename:str) -> bool:
    """
    Check that the expected [generated] file exists.
    """
    return os.path.exists(dirname + '/' + filename)

# #############################################################################
def exec_make(cmdargs:list, extra_env:dict = None) -> bool:
    """Execute `make` command with specified arguments."""
    if extra_env is None:
        extra_env = {}
    try:
        # Need to run `make` from the dir where Makefile lives.
        # Add-in user-specified env-vars to existing env of process.
        result = sp.run(cmdargs, text=True, check=True, capture_output=True,
                        cwd = L3RootDir,
                        env={**os.environ, **extra_env}
                        )
    except sp.CalledProcessError as exc:
        print("sp.run() Status: FAIL, rc =", exc.returncode,
              "\nargs =", exc.args,
              "\nstdout =", exc.stdout,
              "\nstderr =", exc.stderr)
        return False
    for line in str(result).split('\\n'):
        print(line)
    return True

# #############################################################################
def exec_binary(cmdargs:list):
    """Execute a binary, with args, and print output to stdout."""

    with sp.Popen(cmdargs,
                  stdout=sp.PIPE,
                  stderr=sp.PIPE, text=True) as section:
        _stdout, _stderr = section.communicate()

    print('\nExec:', cmdargs)
    print(_stdout)
    return True

# #############################################################################
def build_exp_loc_msg_list(prog_dir:str, main_file:str) -> (list, list):
    """
    Given an input use-cases sample program file name, grep for the calls to
    L3-logging APIs. Re-construct the unpacked LOC-ID string based on the file
    name and line# at the call-sites.

    Arguments:
      prog_dir : Dir of the sample use-case program; e.g., 'single-file-C-program'
      main_file: Name of file where logging is done; e.g., 'test-main.c'

    Returns: A list of unpacked LOC-IDs' string-values.
             A list of logged-msg's printf() msg text.
    """
    # E.g. construct:
    # /home/agurajada/Projects/undoio-l3/use-cases/single-file-C-program
    src_filename = L3USE_CASES_DIR + prog_dir

    # -----------------------------------------------------------------------
    # Build a grep command to grab the call-sites of the L3-logging APIs in
    # a form that we can use to re-construct the unpacked LOC-ID.
    #
    # NOTE: Be careful while constructing this command.
    # `grep -E` seems-to-need space after `-E`, like `-E 'l3_log|l3_log_fast`
    # So, rearrange -E, -n, so that this grep -E works correctly!
    #
    # For some reason, grep | grep -v -E 'Perf|\*' ... is not working
    # through this Python interfaces. So, just do a plain 'grep -E' for now.
    # -----------------------------------------------------------------------
    grep_cmd = r'''egrep -E -n -w "l3_log|l3_log_fast" '''    \
              + src_filename + '/' + main_file

    cmdargs = shlex.split(grep_cmd)
    # print(cmdargs)

    with sp.Popen(cmdargs,
                  stdout=sp.PIPE, stderr=sp.PIPE,
                  text=True) as section:
        _stdout, _stderr = section.communicate()

    loc_list = []
    msg_list = []
    for line in _stdout.split('\n'):
        if len(line) == 0 or fnmatchcase(line, "*Perf*"):
            continue

        split_array = str(line).split(':')
        # print(split_array)

        loc_id = split_array[0]
        loc_list.append(prog_dir + '/' + main_file + ':' + str(loc_id))

        # --------------------------------------------------------------------
        # split_array[1] will be one of:
        #
        #  '    l3_log("Simple-log-msg-Args(1,2)", 1, 2);'
        #  '    l3_log_fast("Fast-logging msg1", 10, 0xdeadbeef);'
        #
        # Split this further on '"' to extract out the actual printf() msg.
        # --------------------------------------------------------------------
        msg    = split_array[1].split('"')[1]
        msg_list.append(msg)

    return (loc_list, msg_list)
